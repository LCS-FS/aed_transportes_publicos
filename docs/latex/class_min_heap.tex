\hypertarget{class_min_heap}{}\doxysection{Min\+Heap\texorpdfstring{$<$}{<} K, V \texorpdfstring{$>$}{>} Class Template Reference}
\label{class_min_heap}\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_min_heap_a8041a62441509d4fd713e3b1bfad8f31}{Min\+Heap}} (int n, const K \&not\+Found)
\item 
int \mbox{\hyperlink{class_min_heap_a17652e042dae3954be25a1cd9e04f3b0}{get\+Size}} ()
\item 
bool \mbox{\hyperlink{class_min_heap_ae5bd0efd391f31ed67634d5eeb50622e}{has\+Key}} (const K \&key)
\item 
void \mbox{\hyperlink{class_min_heap_a708cab4630ba761be49aea0ae536d772}{insert}} (const K \&key, const V \&value)
\item 
void \mbox{\hyperlink{class_min_heap_acb40738ccbaf73f7c093f8504387587b}{decrease\+Key}} (const K \&key, const V \&value)
\item 
K \mbox{\hyperlink{class_min_heap_a3ab07802846cc4314d7ec383180d3b82}{remove\+Min}} ()
\end{DoxyCompactItemize}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_min_heap_a8041a62441509d4fd713e3b1bfad8f31}\label{class_min_heap_a8041a62441509d4fd713e3b1bfad8f31}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!MinHeap@{MinHeap}}
\index{MinHeap@{MinHeap}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{MinHeap()}{MinHeap()}}
{\footnotesize\ttfamily template$<$class K , class V $>$ \\
\mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::\mbox{\hyperlink{class_min_heap}{Min\+Heap}} (\begin{DoxyParamCaption}\item[{int}]{n,  }\item[{const K \&}]{not\+Found }\end{DoxyParamCaption})}

Constructor Cria uma min-\/heap para um máximo de n pares (K, V) com not\+Found a ser retornado quando a heap está vazia 
\begin{DoxyParams}{Parameters}
{\em n} & número máximo de pares (K, V) da heap \\
\hline
{\em not\+Found} & mensagem retornada quando a heap está vazia \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_min_heap_acb40738ccbaf73f7c093f8504387587b}\label{class_min_heap_acb40738ccbaf73f7c093f8504387587b}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!decreaseKey@{decreaseKey}}
\index{decreaseKey@{decreaseKey}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{decreaseKey()}{decreaseKey()}}
{\footnotesize\ttfamily template$<$class K , class V $>$ \\
void \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::decrease\+Key (\begin{DoxyParamCaption}\item[{const K \&}]{key,  }\item[{const V \&}]{value }\end{DoxyParamCaption})}

Diminui o valor de determinada key para o valor recebido 
\begin{DoxyParams}{Parameters}
{\em key} & key a ser alterada \\
\hline
{\em value} & valor para o qual queremos alterar Complexidade Temporal\+: O($\vert$\+V$\vert$), where V = stops \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_min_heap_a17652e042dae3954be25a1cd9e04f3b0}\label{class_min_heap_a17652e042dae3954be25a1cd9e04f3b0}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!getSize@{getSize}}
\index{getSize@{getSize}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{getSize()}{getSize()}}
{\footnotesize\ttfamily template$<$class K , class V $>$ \\
int \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::get\+Size}

Retorna o número de elementos na heap \begin{DoxyReturn}{Returns}
número de elementos na heap 
\end{DoxyReturn}
\mbox{\Hypertarget{class_min_heap_ae5bd0efd391f31ed67634d5eeb50622e}\label{class_min_heap_ae5bd0efd391f31ed67634d5eeb50622e}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!hasKey@{hasKey}}
\index{hasKey@{hasKey}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{hasKey()}{hasKey()}}
{\footnotesize\ttfamily template$<$class K , class V $>$ \\
bool \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::has\+Key (\begin{DoxyParamCaption}\item[{const K \&}]{key }\end{DoxyParamCaption})}

Verifica se uma determinada key está presente na heap 
\begin{DoxyParams}{Parameters}
{\em key} & key que queremos verificar se está na heap \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true se a key estiver presente na heap, false se não Complexidade Temporal\+: O($\vert$\+V$\vert$), where V = stops 
\end{DoxyReturn}
\mbox{\Hypertarget{class_min_heap_a708cab4630ba761be49aea0ae536d772}\label{class_min_heap_a708cab4630ba761be49aea0ae536d772}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!insert@{insert}}
\index{insert@{insert}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}}
{\footnotesize\ttfamily template$<$class K , class V $>$ \\
void \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::insert (\begin{DoxyParamCaption}\item[{const K \&}]{key,  }\item[{const V \&}]{value }\end{DoxyParamCaption})}

Insere o par (key, value) na heap 
\begin{DoxyParams}{Parameters}
{\em key} & key do par a ser inserido \\
\hline
{\em value} & valor do par a ser inserido Complexidade Temporal\+: O($\vert$\+V$\vert$), where V = stops \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_min_heap_a3ab07802846cc4314d7ec383180d3b82}\label{class_min_heap_a3ab07802846cc4314d7ec383180d3b82}} 
\index{MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}!removeMin@{removeMin}}
\index{removeMin@{removeMin}!MinHeap$<$ K, V $>$@{MinHeap$<$ K, V $>$}}
\doxysubsubsection{\texorpdfstring{removeMin()}{removeMin()}}
{\footnotesize\ttfamily template$<$class K , class V $>$ \\
K \mbox{\hyperlink{class_min_heap}{Min\+Heap}}$<$ K, V $>$\+::remove\+Min}

Remove e retorna a key de menor valor \begin{DoxyReturn}{Returns}
key de menor valor Complexidade Temporal\+: O(log$\vert$\+V$\vert$), where V = stops 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
min\+Heap.\+h\end{DoxyCompactItemize}
